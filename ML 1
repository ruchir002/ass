1)	import pandas as pd
2)	import numpy as np
3)	import matplotlib.pyplot as plt
4)	import seaborn as sns
5)	df = pd.read_csv("C:\\Users\\sspm-engg\\Downloads\\archive\\uber.csv")
6)	df
7)	df.head()
8)	df.tail()
9)	df.info()
10)	df.columns
11)	df=df.drop(['Unnamed: 0', 'key'],axis=1)
12)	df
13)	df.head()
14)	df.shape
15)	df.dtypes
16)	df.describe()
17)	df.isnull().sum()
18)	df['dropoff_latitude'].fillna(value=df['dropoff_latitude'].mean(),inplace = True)
19)	df['dropoff_longitude'].fillna(value=df['dropoff_longitude'].median(),inplace = True)
20)	df.isna().sum()
21)	df.dtypes
22)	df.pickup_datetime = pd.to_datetime(df.pickup_datetime,errors='coerce')
23)	df.dtypes
24)	df=df.assign(hour = df.pickup_datetime.dt.hour, day = df.pickup_datetime.dt.day, month = df.pickup_datetime.dt.month, year = df.pickup_datetime.dt.year, dayofweek = df.pickup_datetime.dt.dayofweek)
25)	df.head()
26)	df.drop('pickup_datetime',axis=1)
27)	from math import*
28)	from math import radians, sin, cos, asin, sqrt
29)	def distance_formula(longitude1, latitude1, longitude2, latitude2):
                  travel_dist = []
  for i in range(len(longitude1)):
        # Convert degrees to radians
        lon1, lat1 = radians(longitude1[i]), radians(latitude1[i])
        lon2, lat2 = radians(longitude2[i]), radians(latitude2[i])
        # Haversine formula
        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat/2)**2 + cos(lat1) * cos(lat2) * sin(dlon/2)**2
        c = 2 * asin(sqrt(a))
        distance_km = 6371 * c   # 6371 km = Earthâ€™s radius
        travel_dist.append(distance_km)
    return travel_dist
30)	df['dist_travel_km'] = distance_formula(df['pickup_longitude'].to_numpy(), df['pickup_latitude'].to_numpy(), df['dropoff_longitude'].to_numpy(), df['dropoff_latitude'].to_numpy())
31)	df.dtypes
32)	df.plot(kind="box", subplots=True, layout=(6, 2), figsize=(15, 20))
plt.show()
33)	def remove_outlier(df1, col):
    Q1 = df1[col].quantile(0.25)
    Q3 = df1[col].quantile(0.75)
    IQR = Q3 - Q1  # interquartile range
    lower_whisker = Q1 - 1.5 * IQR
    upper_whisker = Q3 + 1.5 * IQR
    df1[col] = np.clip(df1[col], lower_whisker, upper_whisker)
    return df1
34)	def treat_outliers_all(df1,col_list):
for c in col_list:
        df1 = remove_outlier(df1, c)
    return df1
35)	numeric_cols = df.select_dtypes(include=['number']).columns
36)	df.plot(kind = "box",subplots = True,layout = (7,2),figsize=(15,20))
37)	corr = df.corr()
38)	corr
39)	fig, ax = plt.subplots(figsize=(10, 6))
40)	sns.heatmap(df.corr(), annot=True, cmap='coolwarm', ax=ax)
41)	plt.show()
42)	y = df['fare_amount']
43)	x = df[['pickup_longitude', 'pickup_latitude', 'dropoff_longitude',
   'dropoff_latitude', 'passenger_count']]
44)	from sklearn.model_selection import train_test_split
x = x.fillna(x.mean())
y = y.fillna(y.mean())
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=1)
45)	df.head()
46)	from sklearn.linear_model import LinearRegression
regression = LinearRegression()
47)	regression.fit(x_train,y_train)
48)	regression.intercept_
49)	regression.coef_
50)	prediction = regression.predict(x_test)
print(prediction)
51)	y_test
52)	from sklearn.metrics import r2_score
53)	r2_score(y_test,prediction)
54)	from sklearn.metrics import mean_squared_error
55)	MSE = mean_squared_error(y_test,prediction)
56)	MSE
57)	RMSE = np.sqrt(MSE)
58)	RMSE
59)	from sklearn.ensemble import RandomForestRegressor
60)	rf = RandomForestRegressor(n_estimators=100)
61)	rf.fit(x_train,y_train)
62)	y_pred = rf.predict(x_test)
63)	y_pred
64)	R2_Random = r2_score(y_test,y_pred)
65)	R2_Random
66)	MSE_Random = mean_squared_error(y_test,y_pred)
67)	MSE_Random
68)	RMSE_Random = np. sqrt(MSE_Random)
69)	RMSE_Random
